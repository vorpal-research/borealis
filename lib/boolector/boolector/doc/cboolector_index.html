<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>C Interface &mdash; Boolector 2.2 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Boolector 2.2 documentation" href="index.html" />
    <link rel="up" title="Boolector C API documentation" href="cboolector.html" />
    <link rel="next" title="Boolector Python API documentation" href="pyboolector.html" />
    <link rel="prev" title="Boolector C API documentation" href="cboolector.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pyboolector.html" title="Boolector Python API documentation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cboolector.html" title="Boolector C API documentation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Boolector 2.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="cboolector.html" accesskey="U">Boolector C API documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">C Interface</a><ul>
<li><a class="reference internal" href="#macros">Macros</a></li>
<li><a class="reference internal" href="#typedefs">Typedefs</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#deprecated">Deprecated</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cboolector.html"
                        title="previous chapter">Boolector C API documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyboolector.html"
                        title="next chapter">Boolector Python API documentation</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="c-interface">
<h1>C Interface<a class="headerlink" href="#c-interface" title="Permalink to this headline">¶</a></h1>
<div class="section" id="macros">
<h2>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h2>
<dl class="macro">
<dt id="c.BOOLECTOR_PARSE_ERROR">
<code class="descname">BOOLECTOR_PARSE_ERROR</code><a class="headerlink" href="#c.BOOLECTOR_PARSE_ERROR" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal"><span class="pre">parse</span> <span class="pre">error</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal"><span class="pre">boolector_parse()</span></code></a></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.BOOLECTOR_SAT">
<code class="descname">BOOLECTOR_SAT</code><a class="headerlink" href="#c.BOOLECTOR_SAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal"><span class="pre">satisfiable</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_limited_sat" title="boolector_limited_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_limited_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_simplify" title="boolector_simplify"><code class="xref c c-func docutils literal"><span class="pre">boolector_simplify()</span></code></a></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.BOOLECTOR_UNKNOWN">
<code class="descname">BOOLECTOR_UNKNOWN</code><a class="headerlink" href="#c.BOOLECTOR_UNKNOWN" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal"><span class="pre">unknown</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_limited_sat" title="boolector_limited_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_limited_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_simplify" title="boolector_simplify"><code class="xref c c-func docutils literal"><span class="pre">boolector_simplify()</span></code></a></p>
</div>
</dd></dl>

<dl class="macro">
<dt id="c.BOOLECTOR_UNSAT">
<code class="descname">BOOLECTOR_UNSAT</code><a class="headerlink" href="#c.BOOLECTOR_UNSAT" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocessor constant representing status <code class="docutils literal"><span class="pre">unsatisfiable</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_limited_sat" title="boolector_limited_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_limited_sat()</span></code></a>, <a class="reference internal" href="#c.boolector_simplify" title="boolector_simplify"><code class="xref c c-func docutils literal"><span class="pre">boolector_simplify()</span></code></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="typedefs">
<h2>Typedefs<a class="headerlink" href="#typedefs" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.boolector_add">
BoolectorNode *<code class="descname">boolector_add</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector addition.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector addition with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_and">
BoolectorNode *<code class="descname">boolector_and</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>and</em>.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_apply">
BoolectorNode *<code class="descname">boolector_apply</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode **<em>&nbsp;arg_nodes</em>, int<em>&nbsp;argc</em>, BoolectorNode *<em>&nbsp;n_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function application on function <code class="docutils literal"><span class="pre">n_fun</span></code> with arguments
<code class="docutils literal"><span class="pre">arg_nodes</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>arg_nodes</strong> &#8211; Arguments to be applied.</li>
<li><strong>argc</strong> &#8211; Number of arguments to be applied.</li>
<li><strong>n_fun</strong> &#8211; Function expression.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Function application on function <code class="docutils literal"><span class="pre">n_fun</span></code> with arguments <code class="docutils literal"><span class="pre">arg_nodes</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_fun" title="boolector_fun"><code class="xref c c-func docutils literal"><span class="pre">boolector_fun()</span></code></a>, <a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal"><span class="pre">boolector_uf()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_array">
BoolectorNode *<code class="descname">boolector_array</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;elem_width</em>, int<em>&nbsp;index_width</em>, const char *<em>&nbsp;symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a one-dimensional bit vector array of size <code class="docutils literal"><span class="pre">2^index_width</span></code>
with elements of bit width <code class="docutils literal"><span class="pre">elem_width</span></code>.</p>
<p>An array variable&#8217;s symbol is used as a simple means of identification,
either when printing a model via <a class="reference internal" href="#c.boolector_print_model" title="boolector_print_model"><code class="xref c c-func docutils literal"><span class="pre">boolector_print_model()</span></code></a>, or generating file
dumps via <a class="reference internal" href="#c.boolector_dump_btor" title="boolector_dump_btor"><code class="xref c c-func docutils literal"><span class="pre">boolector_dump_btor()</span></code></a> and <a class="reference internal" href="#c.boolector_dump_smt2" title="boolector_dump_smt2"><code class="xref c c-func docutils literal"><span class="pre">boolector_dump_smt2()</span></code></a>.
A symbol must be unique but may be NULL in case that no symbol should be
assigned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>elem_width</strong> &#8211; Bit width of array elements (must be greater than zero).</li>
<li><strong>index_width</strong> &#8211; Bit width of array indices (must be greater than zero).</li>
<li><strong>symbol</strong> &#8211; Name of array variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector array of size <code class="docutils literal"><span class="pre">2^index_width</span></code> with elements of bit width <code class="docutils literal"><span class="pre">elem_width</span></code>, and symbol <code class="docutils literal"><span class="pre">symbol</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In contrast to composite expressions, which are maintained uniquely w.r.t.
to their kind, inputs (and consequently, bit width), array variables are
not.  Hence, each call to <a class="reference internal" href="#c.boolector_array" title="boolector_array"><code class="xref c c-func docutils literal"><span class="pre">boolector_array()</span></code></a> with the same arguments will
return a fresh array variable.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_array_assignment">
void <code class="descname">boolector_array_assignment</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n_array</em>, char ***<em>&nbsp;indices</em>, char ***<em>&nbsp;values</em>, int *<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_array_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a model for an array expression.</p>
<p>If <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a> has returned <a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_SAT</span></code></a> and model generation has been
enabled.  The function creates and stores the array of indices into
<code class="docutils literal"><span class="pre">indices</span></code> and the array of corresponding values into <code class="docutils literal"><span class="pre">values</span></code>. The number
size of <code class="docutils literal"><span class="pre">indices</span></code> resp. <code class="docutils literal"><span class="pre">values</span></code> is stored into <code class="docutils literal"><span class="pre">size</span></code>. The array model
simply inspects the set of reads rho, which is associated with each array
expression. See our publication <a class="reference external" href="http://fmv.jku.at/papers/PreinerNiemetzBiere-DIFTS13.pdf">Lemmas on Demand for Lambdas</a> for details.
At indices that do not occur in the model, it is assumed that the array
stores a globally unique default value, for example 0.  The bit vector
assignments to the indices and values have to be freed by
<a class="reference internal" href="#c.boolector_free_bv_assignment" title="boolector_free_bv_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_free_bv_assignment()</span></code></a>. Furthermore, the user has to free the array of
indices and the array of values, respectively of size <code class="docutils literal"><span class="pre">size</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n_array</strong> &#8211; Array operand for which the array model should be built.</li>
<li><strong>indices</strong> &#8211; Pointer to array of index strings.</li>
<li><strong>values</strong> &#8211; Pointer to array of value strings.</li>
<li><strong>size</strong> &#8211; Pointer to size.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_set_opt()</span></code></a> for enabling model generation.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_assert">
void <code class="descname">boolector_assert</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_assert" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a constraint.</p>
<p>Use this function to assert <code class="docutils literal"><span class="pre">node</span></code>.  Added constraints can not be deleted
anymore. After <code class="docutils literal"><span class="pre">node</span></code> has been asserted, it can be safely released by
<a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal"><span class="pre">boolector_release()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector expression with bit width one.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_assume">
void <code class="descname">boolector_assume</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_assume" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an assumption.</p>
<p>Use this function to assume <code class="docutils literal"><span class="pre">node</span></code>. You must enable Boolector&#8217;s
incremental usage via <a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_set_opt()</span></code></a> before you can add assumptions.  In
contrast to assertions added via <a class="reference internal" href="#c.boolector_assert" title="boolector_assert"><code class="xref c c-func docutils literal"><span class="pre">boolector_assert()</span></code></a>, assumptions are discarded
after each call to <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a>. Assumptions and assertions are logically
combined via Boolean <code class="docutils literal"><span class="pre">and</span></code>. Assumption handling in Boolector is analogous
to assumptions in MiniSAT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector expression with bit width one.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_bitvec_sort">
BoolectorSort <code class="descname">boolector_bitvec_sort</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_bitvec_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector sort of bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>width</strong> &#8211; Bit width.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector sort of bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, sorts in Boolector are used for uninterpreted functions, only.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal"><span class="pre">boolector_uf()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_bool_sort">
BoolectorSort <code class="descname">boolector_bool_sort</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_bool_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Boolean sort.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Sort of type Boolean.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal"><span class="pre">boolector_uf()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_bv_assignment">
const char *<code class="descname">boolector_bv_assignment</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_bv_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an assignment string for bit vector expression if
<a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a> has returned <a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_SAT</span></code></a> and model generation has been
enabled.</p>
<p>The expression can be an arbitrary bit vector expression which
occurs in an assertion or current assumption. The assignment string has to
be freed by <a class="reference internal" href="#c.boolector_free_bv_assignment" title="boolector_free_bv_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_free_bv_assignment()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector expression.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">String representing a satisfying assignment to bit vector variables and a consistent assignment for arbitrary bit vector expressions. Each character of the string can be <code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">1</span></code> or <code class="docutils literal"><span class="pre">x</span></code>. The latter represents that the corresponding bit can be assigned arbitrarily.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_set_opt()</span></code></a> for enabling model generation.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_clone">
Btor *<code class="descname">boolector_clone</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_clone" title="Permalink to this definition">¶</a></dt>
<dd><p>Clone an instance of Boolector.</p>
<p>The resulting Boolector instance is an exact copy of given Boolector instance
<code class="docutils literal"><span class="pre">btor</span></code>.  Consequently, in a clone and its parent, nodes with the same id
correspond to each other.  Use <a class="reference internal" href="#c.boolector_match_node" title="boolector_match_node"><code class="xref c c-func docutils literal"><span class="pre">boolector_match_node()</span></code></a> to match corresponding
nodes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Original Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The exact (but disjunct) copy of the Boolector instance <code class="docutils literal"><span class="pre">btor</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If Lingeling is used as SAT solver, Boolector can be cloned at any time,
since Lingeling also supports cloning. However, if you use <a class="reference internal" href="#c.boolector_clone" title="boolector_clone"><code class="xref c c-func docutils literal"><span class="pre">boolector_clone()</span></code></a>
with MiniSAT or PicoSAT (no cloning support), Boolector can only be cloned
prior to the first <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a> call.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_concat">
BoolectorNode *<code class="descname">boolector_concat</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the concatenation of two bit vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the bit width <code class="docutils literal"><span class="pre">bit</span> <span class="pre">width</span> <span class="pre">of</span> <span class="pre">n0</span> <span class="pre">+</span> <span class="pre">bit</span> <span class="pre">width</span> <span class="pre">of</span> <span class="pre">n1</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_cond">
BoolectorNode *<code class="descname">boolector_cond</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n_cond</em>, BoolectorNode *<em>&nbsp;n_then</em>, BoolectorNode *<em>&nbsp;n_else</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an if-then-else.</p>
<p>If condition <code class="docutils literal"><span class="pre">n_cond</span></code> is true, then <code class="docutils literal"><span class="pre">n_then</span></code> is returned, else <code class="docutils literal"><span class="pre">n_else</span></code>
is returned.
Nodes <code class="docutils literal"><span class="pre">n_then</span></code> and <code class="docutils literal"><span class="pre">n_else</span></code> must be either both arrays or both bit vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n_cond</strong> &#8211; Bit vector condition with bit width one.</li>
<li><strong>n_then</strong> &#8211; Array or bit vector operand representing the <code class="docutils literal"><span class="pre">if</span></code> case.</li>
<li><strong>n_else</strong> &#8211; Array or bit vector operand representing the <code class="docutils literal"><span class="pre">else</span></code> case.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Either <code class="docutils literal"><span class="pre">n_then</span></code> or <code class="docutils literal"><span class="pre">n_else</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_const">
BoolectorNode *<code class="descname">boolector_const</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_const" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector constant representing the bit vector <code class="docutils literal"><span class="pre">bits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>bits</strong> &#8211; Non-empty and terminated string consisting of zeroes and/or ones representing the bit vector constant specified by <code class="docutils literal"><span class="pre">bits</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector constant with bit width <code class="docutils literal"><span class="pre">strlen</span> <span class="pre">(bits)</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_copy">
BoolectorNode *<code class="descname">boolector_copy</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy expression (increments reference counter).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node to be copied.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Node <code class="docutils literal"><span class="pre">node</span></code> with reference counter incremented.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dec">
BoolectorNode *<code class="descname">boolector_dec</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dec" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector expression that decrements bit vector <code class="docutils literal"><span class="pre">node</span></code> by one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as <code class="docutils literal"><span class="pre">node</span></code> decremented by one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_delete">
void <code class="descname">boolector_delete</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete a boolector instance and free its resources.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Expressions that have not been released properly will not be
deleted from memory. Use <a class="reference internal" href="#c.boolector_get_refs" title="boolector_get_refs"><code class="xref c c-func docutils literal"><span class="pre">boolector_get_refs()</span></code></a> to debug reference
counting. You can also set option <code class="docutils literal"><span class="pre">auto_cleanup</span></code> via
<a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_set_opt()</span></code></a> in order to do the cleanup automatically.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_aiger_ascii">
void <code class="descname">boolector_dump_aiger_ascii</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;file</em>, bool<em>&nbsp;merge_roots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_aiger_ascii" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps bit vector formula to file in ascii AIGER format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance</li>
<li><strong>file</strong> &#8211; Output file.</li>
<li><strong>merge_roots</strong> &#8211; Merge all roots of AIG.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_aiger_binary">
void <code class="descname">boolector_dump_aiger_binary</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;file</em>, bool<em>&nbsp;merge_roots</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_aiger_binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps bit vector formula to file in ascii AIGER format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance</li>
<li><strong>file</strong> &#8211; Output file.</li>
<li><strong>merge_roots</strong> &#8211; Merge all roots of AIG.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_btor">
void <code class="descname">boolector_dump_btor</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_btor" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump formula to file in <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>file</strong> &#8211; File to which the formula should be dumped. The file must be have been opened by the user before.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_btor2">
void <code class="descname">boolector_dump_btor2</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_btor2" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump formula to file in BTOR 2.0 format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>file</strong> &#8211; File to which the formula should be dumped. The file must be have been opened by the user before.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_btor_node">
void <code class="descname">boolector_dump_btor_node</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;file</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_btor_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively dump <code class="docutils literal"><span class="pre">node</span></code> to file in <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>file</strong> &#8211; File to which the expression should be dumped. The file must be have been opened by the user before.</li>
<li><strong>node</strong> &#8211; The expression which should be dumped.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_smt2">
void <code class="descname">boolector_dump_smt2</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_smt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Dumps formula to file in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance</li>
<li><strong>file</strong> &#8211; Output file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_dump_smt2_node">
void <code class="descname">boolector_dump_smt2_node</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;file</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_dump_smt2_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively dump <code class="docutils literal"><span class="pre">node</span></code> to file in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>file</strong> &#8211; File to which the expression should be dumped. The file must be have been opened by the user before.</li>
<li><strong>node</strong> &#8211; The expression which should be dumped.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_eq">
BoolectorNode *<code class="descname">boolector_eq</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector or array equality.</p>
<p>Both operands are either bit vectors with the same bit width or arrays
of the same type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First operand.</li>
<li><strong>n1</strong> &#8211; Second operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_failed">
int <code class="descname">boolector_failed</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_failed" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if assumption <code class="docutils literal"><span class="pre">node</span></code> is a failed assumption.</p>
<p>Failed assumptions are those assumptions, that force an input formula
to become unsatisfiable. Failed assumptions handling in Boolector is
analogous to failed assumptions in MiniSAT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector expression with bit width one.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">1 if assumption is failed, and 0 otherwise.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal"><span class="pre">boolector_assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_false">
BoolectorNode *<code class="descname">boolector_false</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_false" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector constant zero with bit width one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector constant zero with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_first_opt">
const char * <code class="descname">boolector_first_opt</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_first_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the name of the first option in Boolector&#8217;s option list.</p>
<p>Given a Boolector instance <code class="docutils literal"><span class="pre">btor</span></code>, you can use this in combination
with <a class="reference internal" href="#c.boolector_next_opt" title="boolector_next_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_next_opt()</span></code></a> in order to iterate over Boolector options
as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">boolector_first_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boolector_next_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{...}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Btor instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Name of the first option in Boolector&#8217;s option list.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fixate_assumptions">
void <code class="descname">boolector_fixate_assumptions</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fixate_assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Add all assumptions as assertions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal"><span class="pre">boolector_assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_free_array_assignment">
void <code class="descname">boolector_free_array_assignment</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, char **<em>&nbsp;indices</em>, char **<em>&nbsp;values</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_free_array_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Free an assignment string for arrays of bit vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>indices</strong> &#8211; Array of index strings of size <code class="docutils literal"><span class="pre">size</span></code>.</li>
<li><strong>values</strong> &#8211; Array of values strings of size <code class="docutils literal"><span class="pre">size</span></code>.</li>
<li><strong>size</strong> &#8211; Size of arrays <code class="docutils literal"><span class="pre">indices</span></code> and <code class="docutils literal"><span class="pre">values</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_array_assignment" title="boolector_array_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_array_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_free_bits">
void <code class="descname">boolector_free_bits</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;bits</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_free_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a bits string for bit vector constants.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>bits</strong> &#8211; String which has to be freed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_get_bits" title="boolector_get_bits"><code class="xref c c-func docutils literal"><span class="pre">boolector_get_bits()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_free_bv_assignment">
void <code class="descname">boolector_free_bv_assignment</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;assignment</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_free_bv_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Free an assignment string for bit vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>assignment</strong> &#8211; String which has to be freed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_bv_assignment" title="boolector_bv_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_bv_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_free_uf_assignment">
void <code class="descname">boolector_free_uf_assignment</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, char **<em>&nbsp;args</em>, char **<em>&nbsp;values</em>, int<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_free_uf_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Free assignment strings for uninterpreted functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>args</strong> &#8211; Array of argument strings of size <code class="docutils literal"><span class="pre">size</span></code>.</li>
<li><strong>values</strong> &#8211; Array of value string of size <code class="docutils literal"><span class="pre">size</span></code>.</li>
<li><strong>size</strong> &#8211; Size of arrays <code class="docutils literal"><span class="pre">args</span></code> and <code class="docutils literal"><span class="pre">values</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_uf_assignment" title="boolector_uf_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_uf_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fun">
BoolectorNode *<code class="descname">boolector_fun</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode **<em>&nbsp;param_nodes</em>, int<em>&nbsp;paramc</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a function with body <code class="docutils literal"><span class="pre">node</span></code> parameterized over parameters
<code class="docutils literal"><span class="pre">param_nodes</span></code>.</p>
<p>This kind of node is similar to macros in the SMT-LIB standard 2.0.
Note that as soon as a parameter is bound to a function, it can not be
reused in other functions.
Call a function via <a class="reference internal" href="#c.boolector_apply" title="boolector_apply"><code class="xref c c-func docutils literal"><span class="pre">boolector_apply()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>param_nodes</strong> &#8211; Parameters of function.</li>
<li><strong>paramc</strong> &#8211; Number of parameters.</li>
<li><strong>node</strong> &#8211; Function body parameterized over <code class="docutils literal"><span class="pre">param_nodes</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Function over parameterized expression <code class="docutils literal"><span class="pre">node</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_apply" title="boolector_apply"><code class="xref c c-func docutils literal"><span class="pre">boolector_apply()</span></code></a>, <a class="reference internal" href="#c.boolector_param" title="boolector_param"><code class="xref c c-func docutils literal"><span class="pre">boolector_param()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fun_sort">
BoolectorSort <code class="descname">boolector_fun_sort</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorSort *<em>&nbsp;domain</em>, int<em>&nbsp;arity</em>, BoolectorSort<em>&nbsp;codomain</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fun_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function sort.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>domain</strong> &#8211; A list of all the function arguments&#8217; sorts.</li>
<li><strong>arity</strong> &#8211; Number of elements in domain (must be &gt; 0).</li>
<li><strong>codomain</strong> &#8211; The sort of the function&#8217;s return value.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Function sort which maps given domain to given codomain.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently, sorts in Boolector are used for uninterpreted functions, only.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal"><span class="pre">boolector_uf()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_fun_sort_check">
int <code class="descname">boolector_fun_sort_check</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode **<em>&nbsp;arg_nodes</em>, int<em>&nbsp;argc</em>, BoolectorNode *<em>&nbsp;n_fun</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_fun_sort_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if sorts of given arguments matches the function signature.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>arg_nodes</strong> &#8211; Arguments to be checked.</li>
<li><strong>argc</strong> &#8211; Number of arguments to be checked.</li>
<li><strong>n_fun</strong> &#8211; Function expression.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">-1 if all sorts are correct, otherwise it returns the position of the incorrect argument.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_bits">
const char * <code class="descname">boolector_get_bits</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bit vector of a constant node as a bit string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Constant node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">String representing the bits of <code class="docutils literal"><span class="pre">node</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_btor">
Btor *<code class="descname">boolector_get_btor</code><span class="sig-paren">(</span>BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_btor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Boolector instance to which <code class="docutils literal"><span class="pre">node</span></code> belongs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Boolector instance.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_fun_arity">
int <code class="descname">boolector_get_fun_arity</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_fun_arity" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the arity of function <code class="docutils literal"><span class="pre">node</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Function node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Arity of <code class="docutils literal"><span class="pre">node</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_id">
int <code class="descname">boolector_get_id</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the id of a given node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Id of <code class="docutils literal"><span class="pre">node</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_index_width">
int <code class="descname">boolector_get_index_width</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n_array</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_index_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bit width of indices of <code class="docutils literal"><span class="pre">n_array</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n_array</strong> &#8211; Array operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit width of indices of <code class="docutils literal"><span class="pre">n_array</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_desc">
const char * <code class="descname">boolector_get_opt_desc</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_desc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the description of an option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Btor instance.</li>
<li><strong>name</strong> &#8211; Option name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Description of <code class="docutils literal"><span class="pre">name</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_dflt">
int <code class="descname">boolector_get_opt_dflt</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_dflt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the default value of an option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Btor instance.</li>
<li><strong>name</strong> &#8211; Option name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Default value of <code class="docutils literal"><span class="pre">name</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_max">
int <code class="descname">boolector_get_opt_max</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the max value of an option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Btor instance.</li>
<li><strong>name</strong> &#8211; Option name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Max value of <code class="docutils literal"><span class="pre">name</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_min">
int <code class="descname">boolector_get_opt_min</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_min" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the min value of an option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Btor instance.</li>
<li><strong>name</strong> &#8211; Option name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Min value of <code class="docutils literal"><span class="pre">name</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_shrt">
const char * <code class="descname">boolector_get_opt_shrt</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_shrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the short name of an option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Btor instance.</li>
<li><strong>name</strong> &#8211; Option name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Short name of <code class="docutils literal"><span class="pre">name</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_opt_val">
int <code class="descname">boolector_get_opt_val</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_opt_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current value of an option.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Btor instance.</li>
<li><strong>name</strong> &#8211; Option name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Current value of <code class="docutils literal"><span class="pre">name</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_refs">
int <code class="descname">boolector_get_refs</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_refs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of external references to the boolector library.</p>
<p>Internally, Boolector manages an expression DAG with reference counting.
Use <a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal"><span class="pre">boolector_release()</span></code></a> to properly release an expression.  Before you
finally call <a class="reference internal" href="#c.boolector_delete" title="boolector_delete"><code class="xref c c-func docutils literal"><span class="pre">boolector_delete()</span></code></a>, <a class="reference internal" href="#c.boolector_get_refs" title="boolector_get_refs"><code class="xref c c-func docutils literal"><span class="pre">boolector_get_refs()</span></code></a> should return 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Number of external references owned by the user.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_symbol">
const char *<code class="descname">boolector_get_symbol</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;var</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the symbol of an expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>var</strong> &#8211; Array or bit vector variable, parameter, uninterpreted function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Symbol of expression.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_var" title="boolector_var"><code class="xref c c-func docutils literal"><span class="pre">boolector_var()</span></code></a>, <a class="reference internal" href="#c.boolector_array" title="boolector_array"><code class="xref c c-func docutils literal"><span class="pre">boolector_array()</span></code></a>, <a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal"><span class="pre">boolector_uf()</span></code></a>, <a class="reference internal" href="#c.boolector_param" title="boolector_param"><code class="xref c c-func docutils literal"><span class="pre">boolector_param()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_trapi">
FILE *<code class="descname">boolector_get_trapi</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_trapi" title="Permalink to this definition">¶</a></dt>
<dd><p>Return API trace file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">API trace output file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_get_width">
int <code class="descname">boolector_get_width</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_get_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bit width of an expression.</p>
<p>If the expression
is an array, it returns the bit width of the array elements.
If the expression
is a function, it returns the bit width of the function&#8217;s return value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit width of <code class="docutils literal"><span class="pre">node</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_iff">
BoolectorNode *<code class="descname">boolector_iff</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_iff" title="Permalink to this definition">¶</a></dt>
<dd><p>Create Boolean equivalence.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have bit width one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Equivalence n0 &lt;=&gt; n1 with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_implies">
BoolectorNode *<code class="descname">boolector_implies</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_implies" title="Permalink to this definition">¶</a></dt>
<dd><p>Create boolean implication.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have bit width one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; Bit vector node representing the premise.</li>
<li><strong>n1</strong> &#8211; Bit vector node representing the conclusion.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Implication n0 =&gt; n1 with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_inc">
BoolectorNode *<code class="descname">boolector_inc</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_inc" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector expression that increments bit vector <code class="docutils literal"><span class="pre">node</span></code> by one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as <code class="docutils literal"><span class="pre">node</span></code> incremented by one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_int">
BoolectorNode *<code class="descname">boolector_int</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;i</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector constant representing the signed integer <code class="docutils literal"><span class="pre">i</span></code> with bit
width <code class="docutils literal"><span class="pre">width</span></code>.</p>
<p>The constant is obtained by either truncating bits or by
signed extension (padding with ones).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>i</strong> &#8211; Signed integer value.</li>
<li><strong>width</strong> &#8211; Number of bits which must be greater than zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector constant with bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_array">
int <code class="descname">boolector_is_array</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is an array node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if <code class="docutils literal"><span class="pre">node</span></code> is an array, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_array_var">
int <code class="descname">boolector_is_array_var</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_array_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if expression is an array variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if <code class="docutils literal"><span class="pre">node</span></code> is an array variable, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_bound_param">
int <code class="descname">boolector_is_bound_param</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_bound_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given parameter node is bound by a function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Parameter node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if <code class="docutils literal"><span class="pre">node</span></code> is bound, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_const">
int <code class="descname">boolector_is_const</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_const" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a constant node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if <code class="docutils literal"><span class="pre">node</span></code> is a constant, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_equal_sort">
int <code class="descname">boolector_is_equal_sort</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_equal_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> have the same sort or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First operand.</li>
<li><strong>n1</strong> &#8211; Second operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> have the same sort, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_fun">
int <code class="descname">boolector_is_fun</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_fun" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a function node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if <code class="docutils literal"><span class="pre">node</span></code> is a function, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_param">
int <code class="descname">boolector_is_param</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a parameter node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if <code class="docutils literal"><span class="pre">node</span></code> is a parameter, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_is_var">
int <code class="descname">boolector_is_var</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_is_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if given node is a bit vector variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if <code class="docutils literal"><span class="pre">node</span></code> is a bit vector variable, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_limited_sat">
int <code class="descname">boolector_limited_sat</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;lod_limit</em>, int<em>&nbsp;sat_limit</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_limited_sat" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an input formula and limit the search by the number of lemmas
generated and the number of conflicts encountered by the underlying
SAT solver.</p>
<p>An input formula is defined by constraints added via <a class="reference internal" href="#c.boolector_assert" title="boolector_assert"><code class="xref c c-func docutils literal"><span class="pre">boolector_assert()</span></code></a>.
You can guide the search for a solution to an input formula by making
assumptions via <a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal"><span class="pre">boolector_assume()</span></code></a>.</p>
<p>If you want to call this function multiple times then you must enable
Boolector&#8217;s incremental usage mode via <a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_set_opt()</span></code></a> before.
Otherwise, this function can only be called once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>lod_limit</strong> &#8211; Limit for lemmas on demand (-1 unlimited).</li>
<li><strong>sat_limit</strong> &#8211; Conflict limit for SAT solver (-1 unlimited).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_SAT</span></code></a> if the input formula is satisfiable (under possibly given assumptions), <a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNSAT</span></code></a> if the instance is unsatisfiable, and  <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a> if the instance could not be solved within given limits.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_bv_assignment" title="boolector_bv_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_bv_assignment()</span></code></a>, <a class="reference internal" href="#c.boolector_array_assignment" title="boolector_array_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_array_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_match_node">
BoolectorNode *<code class="descname">boolector_match_node</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_match_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the node belonging to Boolector instance <code class="docutils literal"><span class="pre">btor</span></code> that matches
given BoolectorNode <code class="docutils literal"><span class="pre">node</span></code> by id. This is intended to be used for handling
expressions of a cloned instance (<a class="reference internal" href="#c.boolector_clone" title="boolector_clone"><code class="xref c c-func docutils literal"><span class="pre">boolector_clone()</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Boolector node that matches given <code class="docutils literal"><span class="pre">node</span></code> in Boolector instance <code class="docutils literal"><span class="pre">btor</span></code> by id.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Matching a node against another increases the reference
count of the returned match, which must therefore be released appropriately
(<a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal"><span class="pre">boolector_release()</span></code></a>).
Only nodes created before the <a class="reference internal" href="#c.boolector_clone" title="boolector_clone"><code class="xref c c-func docutils literal"><span class="pre">boolector_clone()</span></code></a> call can be matched.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_match_node_by_id">
BoolectorNode *<code class="descname">boolector_match_node_by_id</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;id</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_match_node_by_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the node belonging to Boolector instance <code class="docutils literal"><span class="pre">btor</span></code> that matches
given <code class="docutils literal"><span class="pre">id</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>id</strong> &#8211; Boolector node id.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The Boolector node that matches given <code class="docutils literal"><span class="pre">node</span></code> in Boolector instance <code class="docutils literal"><span class="pre">btor</span></code> by id.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Matching a node against another increases the reference
count of the returned match, which must therefore be released appropriately
(<a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal"><span class="pre">boolector_release()</span></code></a>).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_mul">
BoolectorNode *<code class="descname">boolector_mul</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bitvector multiplication.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector multiplication with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_nand">
BoolectorNode *<code class="descname">boolector_nand</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_nand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>nand</em>.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ne">
BoolectorNode *<code class="descname">boolector_ne</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector or array inequality.</p>
<p>Both operands are either bit vectors with the same bit width or arrays
of the same type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First operand.</li>
<li><strong>n1</strong> &#8211; Second operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_neg">
BoolectorNode *<code class="descname">boolector_neg</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_neg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the two&#8217;s complement of bit vector <code class="docutils literal"><span class="pre">node</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector representing the two&#8217;s complement of <code class="docutils literal"><span class="pre">node</span></code> with the same bit width as <code class="docutils literal"><span class="pre">node</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_new">
Btor *<code class="descname">boolector_new</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new instance of Boolector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">New Boolector instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_next_opt">
const char * <code class="descname">boolector_next_opt</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;name</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_next_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Given current option <code class="docutils literal"><span class="pre">name</span></code>, get the name of the next option in Boolector&#8217;s
option list.</p>
<p>Given a Boolector instance <code class="docutils literal"><span class="pre">btor</span></code>, you can use this in combination
with <a class="reference internal" href="#c.boolector_first_opt" title="boolector_first_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_first_opt()</span></code></a> in order to iterate over Boolector options
as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">boolector_first_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">);</span> <span class="n">s</span><span class="p">;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">boolector_next_opt</span> <span class="p">(</span><span class="n">btor</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span> <span class="p">{...}</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Btor instance.</li>
<li><strong>name</strong> &#8211; Option name.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Name of the next option in Boolector&#8217;s option list, or 0 if no such next option does exist.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_nor">
BoolectorNode *<code class="descname">boolector_nor</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_nor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>nor</em>.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_not">
BoolectorNode *<code class="descname">boolector_not</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the one&#8217;s complement of bit vector <code class="docutils literal"><span class="pre">node</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit Vector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector representing the one&#8217;s complement of <code class="docutils literal"><span class="pre">node</span></code> with the same bit width as <code class="docutils literal"><span class="pre">node</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_one">
BoolectorNode *<code class="descname">boolector_one</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector constant one with bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>width</strong> &#8211; Number of bits which must be greater than zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector constant one with bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ones">
BoolectorNode *<code class="descname">boolector_ones</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector constant with bit width <code class="docutils literal"><span class="pre">width</span></code>, where each bit is set to
one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>width</strong> &#8211; Number of bits which must be greater than zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector constant -1 with bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_or">
BoolectorNode *<code class="descname">boolector_or</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>or</em>.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_param">
BoolectorNode *<code class="descname">boolector_param</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;width</em>, const char *<em>&nbsp;symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_param" title="Permalink to this definition">¶</a></dt>
<dd><p>Create function parameter.</p>
<p>This kind of node is used to create parameterized expressions, which are
used to create functions. Once a parameter is bound to a function, it
cannot be re-used in other functions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>width</strong> &#8211; Number of bits which must be greater than zero.</li>
<li><strong>symbol</strong> &#8211; Name of parameter.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Parameter expression with bit width <code class="docutils literal"><span class="pre">width</span></code> and symbol <code class="docutils literal"><span class="pre">symbol</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_fun" title="boolector_fun"><code class="xref c c-func docutils literal"><span class="pre">boolector_fun()</span></code></a>, <a class="reference internal" href="#c.boolector_apply" title="boolector_apply"><code class="xref c c-func docutils literal"><span class="pre">boolector_apply()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse">
int <code class="descname">boolector_parse</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;infile</em>, const char *<em>&nbsp;infile_name</em>, FILE *<em>&nbsp;outfile</em>, char **<em>&nbsp;error_msg</em>, int *<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file.</p>
<p>Input file format may be either <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a>, or <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>, the
file type is detected automatically.  If the parser encounters an error, an
explanation of that error is stored in <code class="docutils literal"><span class="pre">error_msg</span></code>. If the input file
specifies a (known) status of the input formula (either sat or unsat), that
status is stored in <code class="docutils literal"><span class="pre">status</span></code>. All output (from commands like e.g.
&#8216;check-sat&#8217; in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>) is printed to <code class="docutils literal"><span class="pre">outfile</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>infile</strong> &#8211; Input file.</li>
<li><strong>infile_name</strong> &#8211; Input file name.</li>
<li><strong>outfile</strong> &#8211; Output file.</li>
<li><strong>error_msg</strong> &#8211; Error message.</li>
<li><strong>status</strong> &#8211; Status of the input formula.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">In the incremental case (right now <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> only) the function returns either <a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_SAT</span></code></a>, <a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNSAT</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>, otherwise it always returns <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>. If a parse error occurs the function returns <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse_btor">
int <code class="descname">boolector_parse_btor</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;infile</em>, const char *<em>&nbsp;infile_name</em>, FILE *<em>&nbsp;outfile</em>, char **<em>&nbsp;error_msg</em>, int *<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse_btor" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file in BTOR format.</p>
<p>See <a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal"><span class="pre">boolector_parse()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>infile</strong> &#8211; Input file.</li>
<li><strong>infile_name</strong> &#8211; Input file name.</li>
<li><strong>outfile</strong> &#8211; Output file.</li>
<li><strong>error_msg</strong> &#8211; Error message.</li>
<li><strong>status</strong> &#8211; Status of the input formula.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a> if a parse error occurred.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse_smt1">
int <code class="descname">boolector_parse_smt1</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;infile</em>, const char *<em>&nbsp;infile_name</em>, FILE *<em>&nbsp;outfile</em>, char **<em>&nbsp;error_msg</em>, int *<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse_smt1" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> format.</p>
<p>See <a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal"><span class="pre">boolector_parse()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>infile</strong> &#8211; Input file.</li>
<li><strong>infile_name</strong> &#8211; Input file name.</li>
<li><strong>outfile</strong> &#8211; Input file.</li>
<li><strong>error_msg</strong> &#8211; Error message.</li>
<li><strong>status</strong> &#8211; Status of the input formula.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">In the incremental case (right now <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> only) the function returns either <a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_SAT</span></code></a>, <a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNSAT</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>, otherwise it always returns <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a>. If a parse error occurs the function returns <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_parse_smt2">
int <code class="descname">boolector_parse_smt2</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;infile</em>, const char *<em>&nbsp;infile_name</em>, FILE *<em>&nbsp;outfile</em>, char **<em>&nbsp;error_msg</em>, int *<em>&nbsp;status</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_parse_smt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse input file in <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format. See <a class="reference internal" href="#c.boolector_parse" title="boolector_parse"><code class="xref c c-func docutils literal"><span class="pre">boolector_parse()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>infile</strong> &#8211; Input file.</li>
<li><strong>infile_name</strong> &#8211; Input file name.</li>
<li><strong>outfile</strong> &#8211; Output file.</li>
<li><strong>error_msg</strong> &#8211; Error message.</li>
<li><strong>status</strong> &#8211; Status of the input formula.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a> or <a class="reference internal" href="#c.BOOLECTOR_PARSE_ERROR" title="BOOLECTOR_PARSE_ERROR"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_PARSE_ERROR</span></code></a> if a parse error occurred.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_print_model">
void <code class="descname">boolector_print_model</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, char *<em>&nbsp;format</em>, FILE *<em>&nbsp;file</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_print_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Print model to output file. This function prints the model for all inputs
to the output file <code class="docutils literal"><span class="pre">file</span></code>. Supported output formats for the model to be
printed are:</p>
<ul>
<li><p class="first"><strong>btor</strong></p>
<p>Use boolector&#8217;s own output format for printing models.</p>
<div class="highlight-c"><div class="highlight"><pre>:c:func:`boolector_print_model` (btor, &quot;btor&quot;, stdout);
</pre></div>
</div>
<p>A possible model would be:</p>
<div class="highlight-python"><div class="highlight"><pre>2 00000100 x
3 00010101 y
4[00] 01 A
</pre></div>
</div>
<p>where the first column indicates the id of an input, the second column
its assignment, and the third column its name (or symbol), if any.
Note that in case that an input is an uninterpreted function or an
array variable,
values in square brackets indicate parameter resp. index values.</p>
</li>
<li><p class="first"><strong>smt2</strong></p>
<p>Use <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a> format for printing models.</p>
<div class="highlight-c"><div class="highlight"><pre>:c:func:`boolector_print_model` (btor, &quot;smt2&quot;, stdout);
</pre></div>
</div>
<p>A possible model would be:</p>
<div class="highlight-python"><div class="highlight"><pre>(model
  (define-fun x () (_ BitVec 8) #b00000100)
  (define-fun y () (_ BitVec 8) #b00010101)
  (define-fun y (
   (y_x0 (_ BitVec 2)))
    (ite (= y_x0 #b00) #b01
      #00))
)
</pre></div>
</div>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>format</strong> &#8211; A string identifying the output format.</li>
<li><strong>file</strong> &#8211; Output file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_print_stats">
void <code class="descname">boolector_print_stats</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_print_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Print statistics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_read">
BoolectorNode *<code class="descname">boolector_read</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n_array</em>, BoolectorNode *<em>&nbsp;n_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a read on array <code class="docutils literal"><span class="pre">n_array</span></code> at position <code class="docutils literal"><span class="pre">n_index</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n_array</strong> &#8211; Array operand.</li>
<li><strong>n_index</strong> &#8211; Bit vector index. The bit width of <code class="docutils literal"><span class="pre">n_index</span></code> must have the same bit width as the indices of <code class="docutils literal"><span class="pre">n_array</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the elements of <code class="docutils literal"><span class="pre">n_array</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_redand">
BoolectorNode *<code class="descname">boolector_redand</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_redand" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <em>and</em> reduction of node <code class="docutils literal"><span class="pre">node</span></code>.</p>
<p>All bits of <code class="docutils literal"><span class="pre">node</span></code> are combined by a Boolean <em>and</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_redor">
BoolectorNode *<code class="descname">boolector_redor</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_redor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <em>or</em> reduction of node <code class="docutils literal"><span class="pre">node</span></code>.</p>
<p>All bits of node <code class="docutils literal"><span class="pre">node</span></code> are combined by a Boolean <em>or</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_redxor">
BoolectorNode *<code class="descname">boolector_redxor</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_redxor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create <em>xor</em> reduction of node <code class="docutils literal"><span class="pre">node</span></code>.</p>
<p>All bits of <code class="docutils literal"><span class="pre">node</span></code> are combined by a Boolean <em>xor</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_release">
void <code class="descname">boolector_release</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_release" title="Permalink to this definition">¶</a></dt>
<dd><p>Release expression (decrements reference counter).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Boolector node to be released.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_release_all">
void <code class="descname">boolector_release_all</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_release_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Release all expressions and sorts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_release" title="boolector_release"><code class="xref c c-func docutils literal"><span class="pre">boolector_release()</span></code></a>, <a class="reference internal" href="#c.boolector_release_sort" title="boolector_release_sort"><code class="xref c c-func docutils literal"><span class="pre">boolector_release_sort()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_release_sort">
void <code class="descname">boolector_release_sort</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorSort<em>&nbsp;sort</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_release_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Release sort (decrements reference counter).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>sort</strong> &#8211; Sort to be released.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_reset_assumptions">
void <code class="descname">boolector_reset_assumptions</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_reset_assumptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all added assumptions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal"><span class="pre">boolector_assume()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_reset_stats">
void <code class="descname">boolector_reset_stats</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_reset_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset statistics (time statistics not included).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_reset_time">
void <code class="descname">boolector_reset_time</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_reset_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset time statistics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_rol">
BoolectorNode *<code class="descname">boolector_rol</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_rol" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a rotate left.</p>
<p>Given bit vector node <code class="docutils literal"><span class="pre">n1</span></code>, the value it represents is the number of bits
by which node <code class="docutils literal"><span class="pre">n0</span></code> is rotated to the left.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand where the bit width is a power of two and greater than 1.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal"><span class="pre">n0</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as <code class="docutils literal"><span class="pre">n0</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ror">
BoolectorNode *<code class="descname">boolector_ror</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ror" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a rotate right.</p>
<p>Given bit vector node <code class="docutils literal"><span class="pre">n1</span></code>, the value it represents is the number of bits by
which node <code class="docutils literal"><span class="pre">n0</span></code> is rotated to the right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand where the bit width is a power of two and greater than 1.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal"><span class="pre">n0</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as <code class="docutils literal"><span class="pre">n0</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_saddo">
BoolectorNode *<code class="descname">boolector_saddo</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_saddo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed bit vector addition overflow detection.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one, which indicates if the addition of <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> overflows in case both operands are treated signed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sat">
int <code class="descname">boolector_sat</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sat" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve an input formula.</p>
<p>An input formula is defined by constraints added via <a class="reference internal" href="#c.boolector_assert" title="boolector_assert"><code class="xref c c-func docutils literal"><span class="pre">boolector_assert()</span></code></a>.
You can guide the search for a solution to an input formula by making
assumptions via <a class="reference internal" href="#c.boolector_assume" title="boolector_assume"><code class="xref c c-func docutils literal"><span class="pre">boolector_assume()</span></code></a>.
Note that assertions and assumptions are combined by boolean <code class="docutils literal"><span class="pre">and</span></code>.</p>
<p>If you want to call this function multiple times, you must enable
Boolector&#8217;s incremental usage mode via <a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_set_opt()</span></code></a>
before. Otherwise, this function may only be called once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_SAT</span></code></a> if the instance is satisfiable and <a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNSAT</span></code></a> if the instance is unsatisfiable.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_bv_assignment" title="boolector_bv_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_bv_assignment()</span></code></a>, <a class="reference internal" href="#c.boolector_array_assignment" title="boolector_array_assignment"><code class="xref c c-func docutils literal"><span class="pre">boolector_array_assignment()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sdiv">
BoolectorNode *<code class="descname">boolector_sdiv</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Create signed division.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Signed division is expressed by means of unsigned
division, where either node is normalized in case that its sign bit is 1.
If the sign bits of <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> do not match, two&#8217;s complement
is performed on the result of the previous unsigned division.
Hence, the behavior in case of a division by zero depends on
<a class="reference internal" href="#c.boolector_udiv" title="boolector_udiv"><code class="xref c c-func docutils literal"><span class="pre">boolector_udiv()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sdivo">
BoolectorNode *<code class="descname">boolector_sdivo</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sdivo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed bit vector division overflow detection.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.
An overflow can happen if <code class="docutils literal"><span class="pre">n0</span></code> represents INT_MIN and <code class="docutils literal"><span class="pre">n1</span></code> represents -1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one, which indicates if the division of <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> overflows in case both operands are treated signed.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unsigned division cannot overflow.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_msg_prefix">
void <code class="descname">boolector_set_msg_prefix</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_msg_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a verbosity message prefix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>prefix</strong> &#8211; Prefix string.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_opt">
void <code class="descname">boolector_set_opt</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;name</em>, int<em>&nbsp;val</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_opt" title="Permalink to this definition">¶</a></dt>
<dd><p>Set option.</p>
<p>List of available options:</p>
<ul>
<li><p class="first"><strong>model_gen</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1 or 2) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) generation of a model for satisfiable instances.</div>
<div class="line">There are two modes for model generation:</div>
</div>
<ul class="simple">
<li>generate model for asserted expressions only (<code class="docutils literal"><span class="pre">value</span></code>: 1)</li>
<li>generate model for all expressions (<code class="docutils literal"><span class="pre">value</span></code>: 2)</li>
</ul>
</li>
<li><p class="first"><strong>incremental</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) incremental mode.</div>
<div class="line">Note that incremental usage turns off some optimization techniques. Disabling incremental usage is currently not supported.</div>
</div>
</li>
<li><p class="first"><strong>incremental_all</strong></p>
<div class="line-block">
<div class="line">Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) incremental solving of all formulas when parsing an input file.</div>
<div class="line">Note that currently, incremental mode while parsing an input file is only supported for <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> input.</div>
</div>
</li>
<li><p class="first"><strong>incremental_in_depth</strong></p>
<div class="line-block">
<div class="line">Set incremental in-depth mode width (<code class="docutils literal"><span class="pre">value</span></code>: int) when parsing an input file.</div>
<div class="line">Note that currently, incremental mode while parsing an input file is only supported for <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> input.</div>
</div>
</li>
<li><p class="first"><strong>incremental_look_ahead</strong></p>
<div class="line-block">
<div class="line">Set incremental look_ahead mode width (<code class="docutils literal"><span class="pre">value</span></code>: int) when parsing an input file.</div>
<div class="line">Note that currently, incremental mode while parsing an input file is only supported for <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> input.</div>
</div>
</li>
<li><p class="first"><strong>incremental_interval</strong></p>
<div class="line-block">
<div class="line">Set incremental interval mode width (<code class="docutils literal"><span class="pre">value</span></code>: int) when parsing an input file.</div>
<div class="line">Note that currently, incremental mode while parsing an input file is only supported for <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a> input.</div>
</div>
</li>
<li><p class="first"><strong>input_format</strong></p>
<div class="line-block">
<div class="line">Force input file format (<code class="docutils literal"><span class="pre">value</span></code>: <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>: -1, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a>: 1, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>: 2) when parsing an input file.</div>
<div class="line">If unspecified, Boolector automatically detects the input file format while parsing.</div>
</div>
</li>
<li><p class="first"><strong>output_number_format</strong></p>
<div class="line-block">
<div class="line">Force output number format (<code class="docutils literal"><span class="pre">value</span></code>: binary: 0, hexadecimal: 1, decimal: 2):</div>
<div class="line">Boolector uses binary by default.</div>
</div>
</li>
<li><p class="first"><strong>output_format</strong></p>
<div class="line-block">
<div class="line">Force output file format (<code class="docutils literal"><span class="pre">value</span></code>: <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a>: -1, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/format-v1.2-r06.08.30.pdf">SMT-LIB v1</a>: 1, <a class="reference external" href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.0-r12.09.09.pdf">SMT-LIB v2</a>: 2).</div>
<div class="line">Boolector uses <a class="reference external" href="http://fmv.jku.at/papers/BrummayerBiereLonsing-BPR08.pdf">BTOR</a> by default.</div>
</div>
</li>
<li><p class="first"><strong>rewrite_level</strong></p>
<div class="line-block">
<div class="line">Set the rewrite level (<code class="docutils literal"><span class="pre">value</span></code>: 0-3) of the rewriting engine.</div>
<div class="line">Boolector uses rewrite level 3 by default, rewrite levels are classified as follows:</div>
</div>
<ul class="simple">
<li>0: no rewriting</li>
<li>1: term level rewriting</li>
<li>2: more simplification techniques</li>
<li>3: full rewriting/simplification</li>
</ul>
<div class="line-block">
<div class="line">Do not alter the rewrite level of the rewriting engine after creating expressions.</div>
</div>
</li>
<li><p class="first"><strong>rewrite_level_pbr</strong></p>
<div class="line-block">
<div class="line">Set the rewrite level (<code class="docutils literal"><span class="pre">value</span></code>: 0-3) for partial beta reduction.</div>
<div class="line">Boolector uses rewrite level 1 by default. Rewrite levels are classified as above.</div>
</div>
</li>
<li><p class="first"><strong>beta_reduce_all</strong></p>
<p>Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) the eager
elimination of lambda expressions via beta reduction.</p>
</li>
<li><p class="first"><strong>probe_beta_reduce_all</strong></p>
<p>Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) probing of
<em>beta_reduce_all</em> until a given lemmas on demand
(<em>pbr_lod_limit</em>) or SAT conflicts limit (<em>pbra_sat_limit</em>).</p>
</li>
<li><p class="first"><strong>pbra_lod_limit</strong></p>
<p>Set lemmas on demand limit for <em>probe_beta_reduce_all</em>.</p>
</li>
<li><p class="first"><strong>pbra_sat_limit</strong></p>
<p>Set SAT conflicts limit for <em>probe_beta_reduce_all</em>.</p>
</li>
<li><p class="first"><strong>pbra_ops_factor</strong></p>
<p>Set factor by which the size of the beta reduced formula may be
greater than the original formula (for <em>probe_beta_reduce_all</em>).</p>
</li>
<li><p class="first"><strong>dual_prop</strong></p>
<p>Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) dual propagation
optimization.</p>
</li>
<li><p class="first"><strong>just</strong></p>
<p>Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) justification
optimization.</p>
</li>
<li><p class="first"><strong>ucopt</strong></p>
<p>Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) unconstrained
optimization.</p>
</li>
<li><p class="first"><strong>lazy_synthesize</strong></p>
<p>Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) lazy synthesis of
bit vector expressions.</p>
</li>
<li><p class="first"><strong>eliminate_slices</strong></p>
<p>Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) slice elimination
on bit vector variables.</p>
</li>
<li><p class="first"><strong>pretty_print</strong></p>
<p>Enable (<code class="docutils literal"><span class="pre">value</span></code>: 1) or disable (<code class="docutils literal"><span class="pre">value</span></code>: 0) pretty printing
when dumping.</p>
</li>
<li><p class="first"><strong>verbosity</strong></p>
<p>Set the level of verbosity.</p>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>name</strong> &#8211; Option name.</li>
<li><strong>val</strong> &#8211; Option value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_sat_solver">
int <code class="descname">boolector_set_sat_solver</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;solver</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_sat_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the SAT solver to use.</p>
<p>Currently, we support <code class="docutils literal"><span class="pre">Lingeling</span></code>, <code class="docutils literal"><span class="pre">PicoSAT</span></code>, and <code class="docutils literal"><span class="pre">MiniSAT</span></code> as string
value of <code class="docutils literal"><span class="pre">solver</span></code> (case insensitive).  This is however
only possible if the corresponding solvers were enabled at compile time.
Call this function after <a class="reference internal" href="#c.boolector_new" title="boolector_new"><code class="xref c c-func docutils literal"><span class="pre">boolector_new()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance</li>
<li><strong>solver</strong> &#8211; Solver identifier string.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Non-zero value if setting the SAT solver was successful.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_sat_solver_lingeling">
int <code class="descname">boolector_set_sat_solver_lingeling</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, const char *<em>&nbsp;optstr</em>, int<em>&nbsp;nofork</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_sat_solver_lingeling" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Lingeling as SAT solver.</p>
<p>This function is only available if Lingeling was enabled at compile time.
Call this function after <a class="reference internal" href="#c.boolector_new" title="boolector_new"><code class="xref c c-func docutils literal"><span class="pre">boolector_new()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>optstr</strong> &#8211; Lingeling option string.</li>
<li><strong>nofork</strong> &#8211; Do not use fork/clone for Lingeling.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Non-zero value if setting the SAT solver was successful.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_sat_solver_minisat">
int <code class="descname">boolector_set_sat_solver_minisat</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_sat_solver_minisat" title="Permalink to this definition">¶</a></dt>
<dd><p>Use MiniSAT as SAT solver.</p>
<p>This function is only available if MiniSAT was enabled at compile time.
Call this function after <a class="reference internal" href="#c.boolector_new" title="boolector_new"><code class="xref c c-func docutils literal"><span class="pre">boolector_new()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Non-zero value if setting the SAT solver was successful.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_sat_solver_picosat">
int <code class="descname">boolector_set_sat_solver_picosat</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_sat_solver_picosat" title="Permalink to this definition">¶</a></dt>
<dd><p>Use PicoSAT as SAT solver.</p>
<p>This function is only available if PicoSAT was enabled at compile time.
Call this function after <a class="reference internal" href="#c.boolector_new" title="boolector_new"><code class="xref c c-func docutils literal"><span class="pre">boolector_new()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Non-zero value if setting the SAT solver was successful.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_symbol">
void <code class="descname">boolector_set_symbol</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;var</em>, const char *<em>&nbsp;symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_symbol" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the symbol of an expression.</p>
<p>Expression must be either an array or
bit vector variable, a parameter, or an uninterpreted function).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>var</strong> &#8211; Array or bit vector variable, parameter, uninterpreted function.</li>
<li><strong>symbol</strong> &#8211; The symbol to be set.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_var" title="boolector_var"><code class="xref c c-func docutils literal"><span class="pre">boolector_var()</span></code></a>, <a class="reference internal" href="#c.boolector_array" title="boolector_array"><code class="xref c c-func docutils literal"><span class="pre">boolector_array()</span></code></a>, <a class="reference internal" href="#c.boolector_uf" title="boolector_uf"><code class="xref c c-func docutils literal"><span class="pre">boolector_uf()</span></code></a>, <a class="reference internal" href="#c.boolector_param" title="boolector_param"><code class="xref c c-func docutils literal"><span class="pre">boolector_param()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_term">
void <code class="descname">boolector_set_term</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int (<em>*fun</em>)(void *), void *<em>&nbsp;state</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_term" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Set a termination callback.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param btor:</th><td class="field-body">Boolector instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">param fun:</th><td class="field-body">The termination callback function.</td>
</tr>
<tr class="field-odd field"><th class="field-name">param state:</th><td class="field-body">The argument to the termination callback function.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_terminate" title="boolector_terminate"><code class="xref c c-func docutils literal"><span class="pre">boolector_terminate()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_set_trapi">
void <code class="descname">boolector_set_trapi</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, FILE *<em>&nbsp;apitrace</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_set_trapi" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the output API trace file and enable API tracing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>apitrace</strong> &#8211; Output file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The API trace output file can also be set via the environment variable
BTORAPITRACE=&lt;filename&gt;.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sext">
BoolectorNode *<code class="descname">boolector_sext</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create signed extension.</p>
<p>The bit vector <code class="docutils literal"><span class="pre">node</span></code> is padded with <code class="docutils literal"><span class="pre">width</span></code> bits where the value
depends on the value of the most significant bit of node <code class="docutils literal"><span class="pre">n</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector node.</li>
<li><strong>width</strong> &#8211; Number of bits to pad.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A bit vector extended by <code class="docutils literal"><span class="pre">width</span></code> bits.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sgt">
BoolectorNode *<code class="descname">boolector_sgt</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sgt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed greater than.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sgte">
BoolectorNode *<code class="descname">boolector_sgte</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sgte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed greater than or equal.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_simplify">
int <code class="descname">boolector_simplify</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_simplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplify current input formula.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_SAT</span></code></a> if the input formula was simplified to true, <a class="reference internal" href="#c.BOOLECTOR_UNSAT" title="BOOLECTOR_UNSAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNSAT</span></code></a> if it was simplified to false, and <a class="reference internal" href="#c.BOOLECTOR_UNKNOWN" title="BOOLECTOR_UNKNOWN"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_UNKNOWN</span></code></a> otherwise.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Each call to <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a> simplifies the input formula as a preprocessing
step.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_slice">
BoolectorNode *<code class="descname">boolector_slice</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em>, int<em>&nbsp;upper</em>, int<em>&nbsp;lower</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector slice of <code class="docutils literal"><span class="pre">node</span></code> from index <code class="docutils literal"><span class="pre">upper</span></code> to index <code class="docutils literal"><span class="pre">lower</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector node.</li>
<li><strong>upper</strong> &#8211; Upper index which must be greater than or equal to zero, and less than the bit width of <code class="docutils literal"><span class="pre">node</span></code>.</li>
<li><strong>lower</strong> &#8211; Lower index which must be greater than or equal to zero, and less than or equal to <code class="docutils literal"><span class="pre">upper</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width <code class="docutils literal"><span class="pre">upper</span> <span class="pre">-</span> <span class="pre">lower</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sll">
BoolectorNode *<code class="descname">boolector_sll</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sll" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a logical shift left.</p>
<p>Given node <code class="docutils literal"><span class="pre">n1</span></code>, the value it represents is the number of zeroes shifted
into node <code class="docutils literal"><span class="pre">n0</span></code> from the right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand where the bit width is a power of two and greater than 1.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal"><span class="pre">n0</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as <code class="docutils literal"><span class="pre">n0</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_slt">
BoolectorNode *<code class="descname">boolector_slt</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_slt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed less than.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_slte">
BoolectorNode *<code class="descname">boolector_slte</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_slte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed less than or equal.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_smod">
BoolectorNode *<code class="descname">boolector_smod</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_smod" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a, signed remainder where its sign matches the sign of the divisor.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal"><span class="pre">n1</span></code> is zero, the behavior of this function depends on <a class="reference internal" href="#c.boolector_urem" title="boolector_urem"><code class="xref c c-func docutils literal"><span class="pre">boolector_urem()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_smulo">
BoolectorNode *<code class="descname">boolector_smulo</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_smulo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create signed multiplication overflow detection.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one, which indicates if the multiplication of <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> overflows in case both operands are treated signed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sra">
BoolectorNode *<code class="descname">boolector_sra</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sra" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an arithmetic shift right.</p>
<p>Analogously to <a class="reference internal" href="#c.boolector_srl" title="boolector_srl"><code class="xref c c-func docutils literal"><span class="pre">boolector_srl()</span></code></a>, but
whether zeroes or ones are shifted in depends on the most significant bit
of <code class="docutils literal"><span class="pre">n0</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand where the bit width is a power of two and greater than 1.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal"><span class="pre">n0</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as <code class="docutils literal"><span class="pre">n0</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_srem">
BoolectorNode *<code class="descname">boolector_srem</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_srem" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed remainder.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.
If <code class="docutils literal"><span class="pre">n1</span></code> is zero, then the result is <code class="docutils literal"><span class="pre">n0</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Analogously to <a class="reference internal" href="#c.boolector_sdiv" title="boolector_sdiv"><code class="xref c c-func docutils literal"><span class="pre">boolector_sdiv()</span></code></a>, the signed remainder is expressed by means
of the unsigned remainder, where either node is normalized in case that its
sign bit is 1.  Hence, in case that <code class="docutils literal"><span class="pre">n1</span></code> is zero, the result depends on
<a class="reference internal" href="#c.boolector_urem" title="boolector_urem"><code class="xref c c-func docutils literal"><span class="pre">boolector_urem()</span></code></a>.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_srl">
BoolectorNode *<code class="descname">boolector_srl</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_srl" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a logical shift right.</p>
<p>Given node <code class="docutils literal"><span class="pre">n1</span></code>, the value it represents is the number of zeroes shifted
into node <code class="docutils literal"><span class="pre">n0</span></code> from the left.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand where the bit width is a power of two and greater than 1.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand with bit width log2 of the bit width of <code class="docutils literal"><span class="pre">n0</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ssubo">
BoolectorNode *<code class="descname">boolector_ssubo</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ssubo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a signed bit vector subtraction overflow detection.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one, which indicates if the subtraction of <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> overflows in case both operands are treated signed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_sub">
BoolectorNode *<code class="descname">boolector_sub</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector subtraction.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_terminate">
int <code class="descname">boolector_terminate</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if a given Boolector instance has been terminated (and or
terminate Boolector) via the previously configured termination callback
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if Boolector is terminated, and false otherwise.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_set_term" title="boolector_set_term"><code class="xref c c-func docutils literal"><span class="pre">boolector_set_term()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_true">
BoolectorNode *<code class="descname">boolector_true</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_true" title="Permalink to this definition">¶</a></dt>
<dd><p>Create constant true. This is represented by the bit vector constant one
with bit width one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector constant one with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_uaddo">
BoolectorNode *<code class="descname">boolector_uaddo</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_uaddo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned bit vector addition overflow detection.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one, which indicates if the addition of <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> overflows in case both operands are treated unsigned.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_udiv">
BoolectorNode *<code class="descname">boolector_udiv</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_udiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Create unsigned division.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.
If <code class="docutils literal"><span class="pre">n1</span></code> is zero, then the result is -1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The behavior that division by zero returns -1 does not exactly
comply with the SMT-LIB standard 1.2 and 2.0 where division by zero is
handled as uninterpreted function. Our semantics are motivated by
real circuits where division by zero cannot be uninterpreted and of course
returns a result.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_uext">
BoolectorNode *<code class="descname">boolector_uext</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;node</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_uext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create unsigned extension.</p>
<p>The bit vector <code class="docutils literal"><span class="pre">node</span></code> is padded with <code class="docutils literal"><span class="pre">width</span></code> * zeroes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>node</strong> &#8211; Bit vector node.</li>
<li><strong>width</strong> &#8211; Number of zeroes to pad.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A bit vector extended by <code class="docutils literal"><span class="pre">width</span></code> zeroes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_uf">
BoolectorNode *<code class="descname">boolector_uf</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorSort<em>&nbsp;sort</em>, const char *<em>&nbsp;symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_uf" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an uninterpreted function with sort <code class="docutils literal"><span class="pre">sort</span></code> and symbol <code class="docutils literal"><span class="pre">symbol</span></code>.
<code class="docutils literal"><span class="pre">btor</span></code> Boolector instance.</p>
<p>An uninterpreted function&#8217;s symbol is used as a simple means of
identification, either when printing a model via <a class="reference internal" href="#c.boolector_print_model" title="boolector_print_model"><code class="xref c c-func docutils literal"><span class="pre">boolector_print_model()</span></code></a>, or
generating file dumps via <a class="reference internal" href="#c.boolector_dump_btor" title="boolector_dump_btor"><code class="xref c c-func docutils literal"><span class="pre">boolector_dump_btor()</span></code></a> and
<a class="reference internal" href="#c.boolector_dump_smt2" title="boolector_dump_smt2"><code class="xref c c-func docutils literal"><span class="pre">boolector_dump_smt2()</span></code></a>.  A symbol must be unique but may be NULL in case that no
symbol should be assigned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sort</strong> &#8211; Sort of the uninterpreted function.</li>
<li><strong>symbol</strong> &#8211; Name of the uninterpreted function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Uninterpreted function of sort <code class="docutils literal"><span class="pre">sort</span></code> and symbol <code class="docutils literal"><span class="pre">symbol</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In contrast to composite expressions, which are maintained
uniquely w.r.t. to their kind, inputs (and consequently, bit width),
uninterpreted functions are not.
Hence, each call to this function returns a fresh uninterpreted function.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_apply" title="boolector_apply"><code class="xref c c-func docutils literal"><span class="pre">boolector_apply()</span></code></a>, <a class="reference internal" href="#c.boolector_fun_sort" title="boolector_fun_sort"><code class="xref c c-func docutils literal"><span class="pre">boolector_fun_sort()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_uf_assignment">
void <code class="descname">boolector_uf_assignment</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n_uf</em>, char ***<em>&nbsp;args</em>, char ***<em>&nbsp;values</em>, int *<em>&nbsp;size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_uf_assignment" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a model for an uninterpreted function.
The function creates and stores the assignments of the function&#8217;s arguments
to array <code class="docutils literal"><span class="pre">args</span></code> and the function&#8217;s return values to array <code class="docutils literal"><span class="pre">values</span></code>.
Arrays <code class="docutils literal"><span class="pre">args</span></code> and <code class="docutils literal"><span class="pre">values</span></code> represent assignment pairs of arguments and
values, i.e., instantiating a function with args[i] yields value values[i].
For functions with arity &gt; 1 args[i] contains a space separated string of
argument assignments, where the order of the assignment strings corresponds
to the order of the function&#8217;s arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n_uf</strong> &#8211; Uninterpreted function node.</li>
<li><strong>args</strong> &#8211; Pointer to array of argument assignment strings.</li>
<li><strong>values</strong> &#8211; Pointer to array of value assignment strings.</li>
<li><strong>size</strong> &#8211; Size of arrays <code class="docutils literal"><span class="pre">args</span></code> and <code class="docutils literal"><span class="pre">values</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function can only be called if <a class="reference internal" href="#c.boolector_sat" title="boolector_sat"><code class="xref c c-func docutils literal"><span class="pre">boolector_sat()</span></code></a> returned
<a class="reference internal" href="#c.BOOLECTOR_SAT" title="BOOLECTOR_SAT"><code class="xref c c-macro docutils literal"><span class="pre">BOOLECTOR_SAT</span></code></a> and model generation was enabled.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#c.boolector_set_opt" title="boolector_set_opt"><code class="xref c c-func docutils literal"><span class="pre">boolector_set_opt()</span></code></a> for enabling model generation</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ugt">
BoolectorNode *<code class="descname">boolector_ugt</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ugt" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned greater than.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ugte">
BoolectorNode *<code class="descname">boolector_ugte</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ugte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned greater than or equal.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ult">
BoolectorNode *<code class="descname">boolector_ult</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ult" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned less than.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_ulte">
BoolectorNode *<code class="descname">boolector_ulte</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_ulte" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned less than or equal.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_umulo">
BoolectorNode *<code class="descname">boolector_umulo</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_umulo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned bit vector multiplication overflow detection.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one, which indicates if the multiplication of <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> overflows in case both operands are treated unsigned.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_unsigned_int">
BoolectorNode *<code class="descname">boolector_unsigned_int</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, unsigned<em>&nbsp;u</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_unsigned_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector constant representing the unsigned integer <code class="docutils literal"><span class="pre">u</span></code> with bit
width <code class="docutils literal"><span class="pre">width</span></code>.</p>
<p>The constant is obtained by either truncating bits or by
unsigned extension (padding with zeroes).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>u</strong> &#8211; Unsigned integer value.</li>
<li><strong>width</strong> &#8211; Number of bits which must be greater than zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector constant with bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_urem">
BoolectorNode *<code class="descname">boolector_urem</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_urem" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned remainder.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.
If <code class="docutils literal"><span class="pre">n1</span></code> is zero, then the result is <code class="docutils literal"><span class="pre">n0</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As in <a class="reference internal" href="#c.boolector_udiv" title="boolector_udiv"><code class="xref c c-func docutils literal"><span class="pre">boolector_udiv()</span></code></a> the behavior if <code class="docutils literal"><span class="pre">n1</span></code> is zero, does
not exactly comply with the SMT-LIB standard 1.2 and 2.0 where the result
is handled as uninterpreted function. Our semantics are motivated by
real circuits, where results can not be uninterpreted.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_usubo">
BoolectorNode *<code class="descname">boolector_usubo</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_usubo" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an unsigned bit vector subtraction overflow detection.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with bit width one, which indicates if the subtraction of <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> overflows in case both operands are treated unsigned.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_var">
BoolectorNode *<code class="descname">boolector_var</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;width</em>, const char *<em>&nbsp;symbol</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector variable with bit width <code class="docutils literal"><span class="pre">width</span></code> and symbol <code class="docutils literal"><span class="pre">symbol</span></code>.</p>
<p>A variable&#8217;s symbol is used as a simple means of identification, either when
printing a model via <a class="reference internal" href="#c.boolector_print_model" title="boolector_print_model"><code class="xref c c-func docutils literal"><span class="pre">boolector_print_model()</span></code></a>, or generating file dumps via
<a class="reference internal" href="#c.boolector_dump_btor" title="boolector_dump_btor"><code class="xref c c-func docutils literal"><span class="pre">boolector_dump_btor()</span></code></a> and <a class="reference internal" href="#c.boolector_dump_smt2" title="boolector_dump_smt2"><code class="xref c c-func docutils literal"><span class="pre">boolector_dump_smt2()</span></code></a>.  A symbol
must be unique but may be NULL in case that no symbol should be assigned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>width</strong> &#8211; Number of bits which must be greater than zero.</li>
<li><strong>symbol</strong> &#8211; Name of variable.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector variable with bit width <code class="docutils literal"><span class="pre">width</span></code> and symbol <code class="docutils literal"><span class="pre">symbol</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In contrast to composite expressions, which are maintained uniquely w.r.t. to their kind, inputs (and consequently, bit width), variables are not. Hence, each call to this function returns a fresh bit vector variable.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="c.boolector_write">
BoolectorNode *<code class="descname">boolector_write</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n_array</em>, BoolectorNode *<em>&nbsp;n_index</em>, BoolectorNode *<em>&nbsp;n_value</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a write on array <code class="docutils literal"><span class="pre">n_array</span></code> at position <code class="docutils literal"><span class="pre">n_index</span></code> with value
<code class="docutils literal"><span class="pre">n_value</span></code>.</p>
<p>The array is updated at exactly one position, all other elements remain
unchanged. The bit width of <code class="docutils literal"><span class="pre">n_index</span></code> must be the same as the bit width of
the indices of <code class="docutils literal"><span class="pre">n_array</span></code>. The bit width of <code class="docutils literal"><span class="pre">n_value</span></code> must be the same as
the bit width of the elements of <code class="docutils literal"><span class="pre">n_array</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n_array</strong> &#8211; Array operand.</li>
<li><strong>n_index</strong> &#8211; Bit vector index.</li>
<li><strong>n_value</strong> &#8211; Bit vector value.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An array where the value at index <code class="docutils literal"><span class="pre">n_index</span></code> has been updated with <code class="docutils literal"><span class="pre">n_value</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_xnor">
BoolectorNode *<code class="descname">boolector_xnor</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_xnor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>xnor</em>.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_xor">
BoolectorNode *<code class="descname">boolector_xor</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, BoolectorNode *<em>&nbsp;n0</em>, BoolectorNode *<em>&nbsp;n1</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a bit vector <em>xor</em>.</p>
<p>The parameters <code class="docutils literal"><span class="pre">n0</span></code> and <code class="docutils literal"><span class="pre">n1</span></code> must have the same bit width.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>n0</strong> &#8211; First bit vector operand.</li>
<li><strong>n1</strong> &#8211; Second bit vector operand.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector with the same bit width as the operands.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="c.boolector_zero">
BoolectorNode *<code class="descname">boolector_zero</code><span class="sig-paren">(</span>Btor *<em>&nbsp;btor</em>, int<em>&nbsp;width</em><span class="sig-paren">)</span><a class="headerlink" href="#c.boolector_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Create bit vector constant zero with bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>btor</strong> &#8211; Boolector instance.</li>
<li><strong>width</strong> &#8211; Number of bits which must be greater than zero.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Bit vector constant zero with bit width <code class="docutils literal"><span class="pre">width</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="deprecated">
<h2>Deprecated<a class="headerlink" href="#deprecated" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="pyboolector.html" title="Boolector Python API documentation"
             >next</a> |</li>
        <li class="right" >
          <a href="cboolector.html" title="Boolector C API documentation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Boolector 2.2 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="cboolector.html" >Boolector C API documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2007-2015, Institute for Formal Models and Verification, Johannes Kepler University, Linz, Austria.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>