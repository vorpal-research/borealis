/*
 * $output_file$
 * This file is generated from the following haskell datatype representation:
 * 
 * $source_expr$
 * 
 * stored in $source_file$
 * using the template file $template_file$
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 */

#ifndef $cpp.guard$
#define $cpp.guard$

#include "$dir$/$basename$.h"
#include "Type/RecordBody.h" // including this is generally fucked up

$cpp.prelude$

namespace borealis {

class TypeFactory;

namespace type {

/** protobuf -> $dir$/$derivedname$.proto
import "$dir$/$basename$.proto";
import "$dir$/RecordBodyRef.proto";

$protobuf.prelude$

package borealis.type.proto;

message $derivedname$ {
    extend borealis.proto.$basename$ {
        optional $derivedname$ ext = $index$;
    }
$protobuf.locals$
$protobuf.descriptor.fields: {f|$if(f.type.builtin)$    $f.type.spec$ $f.type.name$ $f.name$ = $i$;$else$    $f.type.spec$ borealis.proto.$f.type.name$ $f.name$ = $i$;$endif$
}$}

**/
class $derivedname$ : public $basename$ {

    typedef $derivedname$ Self;
    typedef $basename$ Base;

    $derivedname$($cpp.descriptor.fields: {f|$f.type.parameter$ $f.name$}; separator=", "$): $basename$(class_tag(*this))$cpp.descriptor.fields: {f|, $f.name$($f.name$)}$ {}

public:
    friend class ::borealis::TypeFactory;
    
    static bool classof(const Self*) { return true; }
    static bool classof(const Base* b) { return b->getClassTag() == class_tag<Self>(); }
$if(first(cpp.descriptor.fields))$

private:
$cpp.descriptor.fields: {f|    $f.type.store$ $f.name$;
}$
public:
$cpp.descriptor.fields: {f|    $f.type.parameter$ $f.getter$() const { return this->$f.name$; \}
}$$else$$endif$
};

} // namespace type
} // namespace borealis

#endif // $cpp.guard$

