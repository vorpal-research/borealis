/*
 * $fname$
 * This file is generated from the following haskell datatype representation:
 * 
 * $source_expr$
 * 
 * stored in $source_file$
 * using the template file $template$
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 */

#ifndef $guard$
#define $guard$

#include "$dir$/$type.dtname$.h"

$prelude$
namespace borealis {

class TypeFactory;

namespace type {

/** protobuf -> $dir$/$constr.constrName$.proto
import "$dir$/$type.dtname$.proto";

package borealis.type.proto;

message $constr.constrName$ {
    extend borealis.proto.$type.dtname$ {
        optional $constr.constrName$ ext = $index$;
    }
$constr.fields: {f|$if(f.description.builtin)$    optional $f.description.protobufName$ $f.fieldName$ = $i$;$else$    optional borealis.proto.$f.description.protobufName$ $f.fieldName$ = $i$;$endif$
}$}

**/
class $constr.constrName$ : public $type.dtname$ {

    typedef $constr.constrName$ Self;
    typedef $type.dtname$ Base;

    $constr.constrName$($constr.fields: {f|$f.description.parameterName$ $f.fieldName$}; separator=", "$): $type.dtname$(class_tag(*this))$constr.fields: {f|, $f.fieldName$($f.fieldName$)}$ {}

public:
    friend class ::borealis::TypeFactory;
    
    static bool classof(const Self*) { return true; }
    static bool classof(const Base* b) { return b->getClassTag() == class_tag<Self>(); }
$if(first(constr.fields))$

private:
$constr.fields: {f|    $f.description.storeName$ $f.fieldName$;
}$
public:
$constr.fields: {f|    $f.description.parameterName$ $f.getterName$() const { return this->$f.fieldName$; \}
}$$else$$endif$
};

} // namespace type
} // namespace borealis

#endif // $guard$
