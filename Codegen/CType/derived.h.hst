/*
 * $output_file$
 * This file is generated from the following haskell datatype representation:
 * 
 * $source_expr$
 * 
 * stored in $source_file$
 * using the template file $template_file$
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 */

#ifndef $cpp.guard$
#define $cpp.guard$

#include "Util/util.hpp"

#include "$dir$/$basename$.h"
#include "$dir$/CTypeRef.h"
#include "$dir$/CStructMember.h"

$cpp.prelude$

namespace borealis {

class CTypeFactory;

/** protobuf -> $dir$/$derivedname$.proto
import "$dir$/$basename$.proto";
import "$dir$/CStructMember.proto";
import "$dir$/CQualifier.proto";
import "$dir$/CTypeRef.proto";

$protobuf.prelude$

package borealis.proto;

message $derivedname$ {
    extend borealis.proto.$basename$ {
        optional $derivedname$ ext = $"$COUNTER_CTYPE"$;
    }

$protobuf.locals$
$protobuf.descriptor.fields: {f|$if(f.type.builtin)$    $f.type.spec$ $f.type.name$ $f.name$ = $i$;$else$    $f.type.spec$ borealis.proto.$f.type.name$ $f.name$ = $i$;$endif$
}$}

**/

class $derivedname$ : public $basename$ {

    typedef $derivedname$ Self;
    typedef $basename$ Base;

    $derivedname$(const std::string& name$cpp.descriptor.fields: {f|, $f.type.parameter$ $f.name$}; separator=""$): $basename$(class_tag(*this), name)$cpp.descriptor.fields: {f|, $f.name$($f.name$)}$ {}

public:

    friend class ::borealis::CTypeFactory;
    friend class util::enable_special_make_shared<$derivedname$, CTypeFactory>; // enable factory-construction only

    static bool classof(const Self*) { return true; }
    static bool classof(const Base* b) { return b->getClassTag() == class_tag<Self>(); }
$if(first(cpp.descriptor.fields))$

private:
$cpp.descriptor.fields: {f|    $f.type.store$ $f.name$;
}$
public:
$cpp.descriptor.fields: {f|    $f.type.parameter$ $f.getter$() const { return this->$f.name$; \}
}$$else$$endif$
};

} // namespace borealis

#endif // $cpp.guard$

