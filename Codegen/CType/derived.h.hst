/*
 * $output_file$
 * This file is generated from the following haskell datatype representation:
 * 
 * $source_expr$
 * 
 * stored in $source_file$
 * using the template file $template_file$
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 */

#ifndef $cpp.guard$
#define $cpp.guard$

#include "Util/util.hpp"

#include "$dir$/$basename$.h"
#include "$dir$/CTypeRef.h"
#include "$dir$/CStructMember.h"

$cpp.prelude$

namespace borealis {

class CTypeFactory;

class $derivedname$ : public $basename$ {

    typedef $derivedname$ Self;
    typedef $basename$ Base;

    $derivedname$(const std::string& name$cpp.descriptor.fields: {f|, $f.type.parameter$ $f.name$}; separator=""$): $basename$(class_tag(*this), name)$cpp.descriptor.fields: {f|, $f.name$($f.name$)}$ {}

public:

    friend class ::borealis::CTypeFactory;
    friend class util::enable_special_make_shared<$derivedname$, CTypeFactory>; // enable factory-construction only

    static bool classof(const Self*) { return true; }
    static bool classof(const Base* b) { return b->getClassTag() == class_tag<Self>(); }
$if(first(cpp.descriptor.fields))$

private:
$cpp.descriptor.fields: {f|    $f.type.store$ $f.name$;
}$
public:
$cpp.descriptor.fields: {f|    $f.type.parameter$ $f.getter$() const { return this->$f.name$; \}
}$$else$$endif$
};

} // namespace borealis

#endif // $cpp.guard$

