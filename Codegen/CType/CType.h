/*
 * Codegen/CType/CType.h
 * This file is generated from the following haskell datatype representation:
 * 
 * data CType =
    CVoid |
    CInteger { bitsize :: Size, signedness :: LLVMSignedness } |
    CFloat { bitsize:: Size } |
    CPointer { element :: Param CTypeRef } |
    CAlias { original :: Param CTypeRef, qualifier :: Exact CQualifier } |
    CArray { element :: Param CTypeRef, size :: Maybe Size } |
    CStruct { elements :: [Exact CStructMember], opaque :: Bool } |
    CFunction { resultType :: Param CTypeRef, argumentTypes :: [Param CTypeRef] }
      deriving (Show, Eq, Data, Typeable)

 * 
 * stored in Codegen/CType/CType.datatype
 * using the template file Codegen/CType/base.h.hst
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 */

#ifndef CTYPE_H
#define CTYPE_H

#include <memory>
#include <string>
#include <iostream>

#include "Util/typeindex.hpp"

namespace borealis {

enum class CQualifier{ CONST = 0, VOLATILE = 1, RESTRICT = 2, TYPEDEF = 3 };

/** protobuf -> Codegen/CType/CQualifier.proto
package borealis.proto;

enum CQualifier {
    CONST = 0; VOLATILE = 1; RESTRICT = 2; TYPEDEF = 3;
}

**/

namespace proto { class CType; }

/** protobuf -> Codegen/CType/CType.proto
package borealis.proto;

message CType {
    optional string name = 1;

    extensions 16 to 64;
}

**/

class CType : public ClassTag {
    std::string name;

protected:
    CType(const CType&) = default;
    
public:
    CType(id_t id, const std::string& name) : ClassTag(id), name(name) {};

    typedef std::shared_ptr<const CType> Ptr;

    const std::string& getName() const { return name; }

    friend std::ostream& operator<<(std::ostream& ost, const CType& ct) {
        return ost << ct.getName();
    }

    friend std::ostream& operator<<(std::ostream& ost, CType::Ptr ct) {
        return ost << ct->getName();
    }

private:
    void dump() {
        std::cerr << getName() << std::endl;
    }
};

} // namespace borealis

namespace std {
template<>
struct hash<borealis::CType::Ptr> {
    size_t operator()(const borealis::CType::Ptr& t) const {
        return reinterpret_cast<size_t>(t.get());
    }
};
template<>
struct hash<const borealis::CType::Ptr> {
    size_t operator()(const borealis::CType::Ptr& t) const {
        return reinterpret_cast<size_t>(t.get());
    }
};
} // namespace std

#endif //CTYPE_H"