/*
 * Codegen/CType/CType.h
 * This file is generated from the following haskell datatype representation:
 * 
 * data CType = 
    CInteger { bitsize :: Size, signedness :: LLVMSignedness } |
    CFloat { bitsize:: Size } |
    CPointer { element :: Param CTypeRef } |
    CAlias { original :: Param CTypeRef, qualifier :: Exact CQualifier } |
    CArray { element :: Param CTypeRef, size :: Maybe Size } |
    CStruct { elements :: [Exact CStructMember] } |
    CFunction { resultType :: Param CTypeRef, argumentTypes :: [Param CTypeRef] }
      deriving (Show, Eq, Data, Typeable)

 * 
 * stored in Codegen/CType/CType.datatype
 * using the template file Codegen/CType/base.h.hst
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 */

#ifndef CTYPE_H
#define CTYPE_H

#include <memory>
#include <string>

#include "Util/typeindex.hpp"

namespace borealis {

enum class CQualifier{ CONST, VOLATILE, RESTRICT, TYPEDEF };

class CType : public ClassTag {
    std::string name;

protected:
    CType(const CType&) = default;
    
public:
    CType(id_t id, const std::string& name) : ClassTag(id), name(name) {};

    typedef std::shared_ptr<const CType> Ptr;

    const std::string& getName() const { return name; }
};

} // namespace borealis

namespace std {
template<>
struct hash<borealis::CType::Ptr> {
    size_t operator()(const borealis::CType::Ptr& t) const {
        return reinterpret_cast<size_t>(t.get());
    }
};
template<>
struct hash<const borealis::CType::Ptr> {
    size_t operator()(const borealis::CType::Ptr& t) const {
        return reinterpret_cast<size_t>(t.get());
    }
};
} // namespace std

#endif //CTYPE_H"