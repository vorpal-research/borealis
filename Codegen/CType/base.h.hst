/*
 * $output_file$
 * This file is generated from the following haskell datatype representation:
 * 
 * $source_expr$
 * 
 * stored in $source_file$
 * using the template file $template_file$
 * 
 * DO NOT EDIT THIS FILE DIRECTLY
 */

#ifndef $cpp.guard$
#define $cpp.guard$

#include <memory>
#include <string>
#include <iostream>

#include "Util/typeindex.hpp"

namespace borealis {

enum class CQualifier{ CONST = 0, VOLATILE = 1, RESTRICT = 2, TYPEDEF = 3 };

/** protobuf -> $dir$/CQualifier.proto
package borealis.proto;

enum CQualifier {
    CONST = 0; VOLATILE = 1; RESTRICT = 2; TYPEDEF = 3;
}

**/

namespace proto { class $basename$; }

/** protobuf -> $dir$/$basename$.proto
package borealis.proto;

message $basename$ {
    optional string name = 1;

    extensions 16 to 64;
}

**/

class $basename$ : public ClassTag {
    std::string name;

protected:
    $basename$(const $basename$&) = default;
    
public:
    $basename$(id_t id, const std::string& name) : ClassTag(id), name(name) {};

    typedef std::shared_ptr<const $basename$> Ptr;

    const std::string& getName() const { return name; }

    friend std::ostream& operator<<(std::ostream& ost, const $basename$& ct) {
        return ost << ct.getName();
    }

    friend std::ostream& operator<<(std::ostream& ost, $basename$::Ptr ct) {
        return ost << ct->getName();
    }

private:
    void dump() {
        std::cerr << getName() << std::endl;
    }
};

} // namespace borealis

namespace std {
template<>
struct hash<borealis::$basename$::Ptr> {
    size_t operator()(const borealis::$basename$::Ptr& t) const {
        return reinterpret_cast<size_t>(t.get());
    }
};
template<>
struct hash<const borealis::$basename$::Ptr> {
    size_t operator()(const borealis::$basename$::Ptr& t) const {
        return reinterpret_cast<size_t>(t.get());
    }
};
} // namespace std

#endif //$cpp.guard$"
